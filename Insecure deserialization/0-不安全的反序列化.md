# 不安全的反序列化

> Insecure deserialization：https://portswigger.net/web-security/deserialization

## 什么是序列化？

序列化是将复杂的数据结构(如对象及其字段)转换为“更扁平”格式的过程，这种格式可以作为连续的字节流发送和接收。序列化数据使它更简单:

- - 将复杂数据写入进程间内存、文件或数据库
  - 例如，通过网络、应用程序的不同组件之间或在API调用中发送复杂数据

至关重要的是，当序列化对象时，它的状态也被持久化。换句话说，对象的属性及其赋值被保留。

## 序列化 vs 反序列化

反序列化是将此字节流还原为原始对象的完全功能副本的过程，其状态与序列化时完全相同。然后，网站的逻辑可以与这个反序列化的对象交互，就像它与任何其他对象一样。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1603451768157-ec58b7a2-ba9c-4850-9a77-28a9faec030b.png)

许多编程语言都提供了对序列化的本机支持。具体如何序列化对象取决于语言。一些语言将对象序列化为二进制格式，而其他语言使用不同的字符串格式，具有不同程度的人类可读性。请注意，原始对象的所有属性都存储在序列化的数据流中，包括任何私有字段。为了防止字段被序列化，必须在类声明中显式地将其标记为“transient”。

请注意，在使用不同的编程语言时，序列化可以称为 marshalling (Ruby)或pickling (Python)。在此上下文中，这些术语是“序列化”的同义词。

## 什么是不安全的反序列化？

不安全反序列化是指用户可控制的数据被网站反序列化。这可能使攻击者能够操作序列化的对象，以便将有害的数据传递到应用程序代码中。

甚至可以用完全不同类的对象替换序列化的对象。令人担忧的是，对网站可用的任何类的对象都将被反序列化和实例化，而不管期望的是哪个类。由于这个原因，不安全的反序列化有时被称为“对象注入”漏洞。

意外类的对象可能导致异常。然而，到这个时候，损害可能已经造成。许多基于反序列化的攻击在反序列化完成之前就完成了。这意味着反序列化过程本身可以发起攻击，即使网站本身的功能与恶意对象没有直接交互。因此，基于强类型语言的网站也容易受到这些技术的攻击。

## 不安全的反序列化漏洞是怎么产生的？

不安全反序列化通常会出现，因为普遍缺乏对反序列化用户可控制数据的危险程度的了解。理想情况下，用户输入永远都不应该被反序列化。

然而，有时网站所有者认为他们是安全的，因为他们实现了某种形式的附加检查反序列化数据。这种方法通常是无效的，因为它几乎不可能实现验证或通过处理来解释每一种可能发生的情况。这些检查从根本上也是有缺陷的，因为它们依赖于在反序列化后对数据进行检查，而在许多情况下，这样做会太晚，无法阻止攻击。

反序列化的对象通常被认为是值得信任的，因此也可能出现漏洞。特别是在使用具有二进制序列化格式的语言时，开发人员可能会认为用户无法有效地读取或操作数据。然而，尽管这可能需要更多的努力，但攻击者可以像利用基于字符串的格式一样利用二进制序列化对象。

基于反序列化的攻击也是可能的，因为现代网站中存在大量的依赖关系。典型的站点可能实现许多不同的库，每个库也有自己的依赖关系。这将创建大量难以安全管理的类和方法池。由于攻击者可以创建这些类的任何实例，因此很难预测可以对恶意数据调用哪些方法。如果攻击者能够将一长串意外的方法调用链接在一起，将数据传递到与初始源完全无关的接收器，那么这种情况尤其如此。因此，几乎不可能预测恶意数据流并堵住每个潜在的漏洞。

简而言之，可以认为不可能安全地反序列化不受信任的输入。

## 不安全的反序列化的影响

不安全反序列化的影响可能非常严重，因为它提供了一个入口点，导致攻击面大量增加。它允许攻击者以有害的方式重用现有的应用程序代码，从而导致大量其他漏洞，通常是远程代码执行。

即使在不可能执行远程代码的情况下，不安全的反序列化也会导致特权升级、任意文件访问和拒绝服务攻击。

## 如何利用不安全的反序列化漏洞？

> Exploiting insecure deserialization vulnerabilities：https://portswigger.net/web-security/deserialization/exploiting

## 如何阻止不安全的反序列化漏洞？

一般来说，除非绝对必要，否则应该避免对用户输入进行反序列化。在许多情况下，它可能启用的高度严重的攻击，而且防范这些攻击的困难，超过了它带来的好处。

如果确实需要对来自不可信来源的数据进行反序列化，则应采用健壮的措施以确保数据没有被篡改。例如，您可以实现一个数字签名来检查数据的完整性。但是，请记住，任何检查都必须在开始反序列化过程之前进行。否则，它们就没什么用了。

如果可能，您应该避免使用通用的反序列化特性。这些方法中的序列化数据包含原始对象的所有属性，包括可能包含敏感信息的私有字段。相反，您可以创建自己的特定于类的序列化方法，这样至少可以控制公开哪些字段。

最后，请记住，该漏洞是对用户输入的反序列化，而不是出现随后处理数据的gadget链。不要依赖于尝试消除您在测试期间识别的gadget链。由于web上的跨库依赖关系几乎肯定存在于您的网站上，所以尝试将它们全部插入是不切实际的。在任何时候，公开记录的内存损坏利用也是一个因素，这意味着您的应用程序无论如何都可能受到攻击。