# 9-Windows Buffer Overflows

> 更详细的内容请查看 Penetration with Kali Linux 第10、11章

## x86架构简介

### 程序内存

当执行二进制应用程序时，它在现代计算机使用的内存边界内以非常特定的方式分配内存。下图显示了在Windows中进程内存是如何在应用程序使用的最低内存地址(0x00000000)和最高内存地址(0x7FFFFFFF)之间分配的:

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605316663808-c748a380-b51f-4954-a1a6-1ca4e7f659e7.png)

#### 堆栈

当线程运行时，它从程序映像中或从各种动态链接库(dll)中执行代码。线程需要一个存储函数、局部变量和程序控制信息的短期数据区域，这个区域被称为堆栈。为了方便多个线程的独立执行，运行中的应用程序中的每个线程都有自己的栈。

栈内存被CPU“视为”后进先出(LIFO)结构。这本质上意味着在访问堆栈时，放在堆栈顶部(“推入”)的项目首先被移除(“弹出”)。x86体系结构实现了专用的PUSH和POP组装指令，以便分别向堆栈添加或删除数据。

#### 函数返回

当线程中的代码调用函数时，它必须知道函数完成后返回哪个地址。这个“返回地址”(连同函数的参数和局部变量)被存储在堆栈上。这个数据集合与一个函数调用相关联，并存储在堆栈内存的一个部分中，称为堆栈帧。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605316793354-fa7fffa6-4caf-4389-a50e-b9c8b557acfb.png)

当函数结束时，返回地址从堆栈中取出，用于将执行流恢复到主程序或调用函数。

### CPU 寄存器

为了执行有效的代码执行，CPU维护和使用一系列的9个32位寄存器(在32位平台上)。寄存器是很小的、非常高速的CPU存储位置，可以在其中有效地读取或操作数据。这九个寄存器，包括这些寄存器的高位和低位的命名法，如下图所示。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605316866768-c92beaf9-9714-46bd-b24d-4e2da0099356.png)

寄存器名是为16位体系结构建立的，然后随着32位(x86)平台的出现而扩展，因此寄存器首字母缩写中有字母“E”。每个寄存器可以包含一个32位值(允许值在0到0xFFFFFFFF之间)，也可以在各自的子寄存器中包含16位或8位值，如下图中的EAX寄存器所示。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605316897300-9068074f-dee2-4f77-8556-588b2495146a.png)

#### 通用寄存器

几种寄存器，包括EAX、EBX、ECX、EDX、ESI和EDI，通常用作通用寄存器来存储临时数据。关于这个讨论还有更多的内容(在各种在线资源中有解释)，但是我们需要了解的主要寄存器如下所述:

- EAX(累加器):算术和逻辑指令
- EBX(基址):内存地址的基指针
- ECX(计数器):循环计数器，移位计数器，旋转计数器
- EDX(数据):I/O端口寻址，乘法和除法
- ESI(源索引):在字符串复制操作中，数据和源的指针寻址
- EDI(目标索引):在字符串复制操作中，数据和目标的指针寻址

#### ESP - 堆栈指针

如前所述，堆栈用于存储数据、指针和参数。由于堆栈是动态的，并且在程序执行过程中不断变化，ESP，即堆栈指针，通过存储一个指针来“跟踪”最近引用的堆栈位置(堆栈顶部)。

指针是对内存中地址(或位置)的引用。当我们说寄存器“存储指针”或“指向”地址时，这本质上意味着寄存器正在存储那个目标地址。

#### EBP - 基指针

由于堆栈在线程执行期间是不断变化的，因此函数很难定位自己的堆栈帧，堆栈帧存储了所需的参数、局部变量和返回地址。EBP，基指针，解决这个问题的方法是在函数被调用时存储一个指向堆栈顶部的指针。通过访问EBP，函数在执行时可以很容易地从它自己的堆栈帧(通过偏移量)引用信息。

#### EIP - 指令指针

指令指针EIP对于我们的目的来说是最重要的寄存器之一，因为它总是指向下一个要执行的代码指令。由于EIP本质上指导程序流，因此它是攻击者在利用任何内存破坏漏洞(如缓冲区溢出)时的主要目标。

## 缓冲区溢出演练

下面是一个简单的C程序，代码上是存在缓冲区溢出的风险的，但是我链接编译之后，在ollydbg里面看，多出了一个检查缓冲区溢出的函数。所以最后没有演示出成功的效果。

```
#include <stdio.h>
#include <string.h>

int main(int argc,char *argv[])
{
    char buffer[64];
    if(argc < 2)
    {
        printf("Error - You must supply at least one argument");
        return 1;
    }
    strcpy(buffer,argv[1]);
    return 0;
}
```

在这种情况下，main函数首先定义了一个名为buffer的字符数组，最多可以容纳64个字符。因为这个变量是在函数中定义的，C编译器将把它当作一个局部变量，并在堆栈上为它保留空间(64字节)。具体地说，当程序运行时，这个内存空间将在主函数堆栈框架中保留。

如果传递给主函数的参数是64个字符或更少，这个程序将像预期的那样工作并正常退出。然而，由于没有检查输入的大小，如果参数较长，比如80字节，堆栈中邻近目标缓冲区的部分将被剩余的16个字符覆盖，溢出数组边界。下图说明了这一点。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605322379496-3530074e-53f0-4208-881c-3d905adbb268.png)

### 调试

文中使用的是Immunity Debugger，下面我用吾爱破解的OllyDbg演示。

下面是第一次打开的界面，大致分为四块，首先我们先打开我们测试的程序，左上角文件 - 打开。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605322653898-444f21f5-47f4-42df-a4e6-9d2ad8c3f1f0.png)

因为这个程序需要在打开的时候传入参数，我们直接在下方的参数先输入12个A。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605322784696-8d8cbdca-0ded-43ee-8acc-4ad873b5bc6a.png)

加载之后就会如下图所示:

①区域显示了组成应用程序的汇编指令。高亮显示的指令(push ebp)是接下来要执行的汇编指令，它位于进程内存空间中的地址0x00401240。

②区域就是寄存器区域，用来显示当前各个寄存器里的值，可以看到EIP显示的是00401240，也代表着下条要执行的指令位于0x00401240。

③区域显示显示了任意给定地址的内存内容。与堆栈窗口类似，它显示三列，包括内存地址和十六进制和ASCII表示的数据。顾名思义，这个窗口在搜索或分析进程内存空间中的特定值时很有用，它可以通过右键单击窗口内容来访问上下文菜单，以不同格式显示数据。

④区域显示)显示了堆栈及其内容。这个视图包含四列:内存地址、驻留在该地址的十六进制数据、数据的ASCII表示，以及一个动态注释(在可用时提供与特定堆栈条目相关的附加信息)。数据本身(第二列)显示为32位值，称为DWORD，显示为4个十六进制字节。注意，这个窗格显示堆栈顶部的地址0x0018FF8，实际上，这是存储在寄存器窗口中的ESP中的值:

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605323733848-ebbf0f1c-61ec-409d-b4d6-6cd51fe5834d.png)

经过调试程序打开，我们的入口地址实际上是被改变的，我们需要自己定位到自己感兴趣的地方，程序中有一个提示字符串，我们右键汇编指令区域，选择查找 - 所有参考文本字串。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605323511256-83675212-8416-4e8a-8ec3-f8e71d65cfaf.png)

在出现的窗口，我们可以看到我们想要的字符串 “Error - You must supply at least one argument”：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605323871651-30d01b60-81b4-4118-8d41-295921e7646b.png)

双击这个字符串，会跳转到程序中汇编指令的所在地址，我们可以看到下面有一个很明显的strcpy字样的调用函数的指令，这个应该就是我们感兴趣的地方，单击这条指令，按F2下断点：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605323980250-835bc0ad-c760-448c-b076-50404ad2f0c3.png)

下了断点，指令的地址会变红，然后点击上方的播放按钮，就可以运行程序：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605324138699-4964bf26-56dd-43e2-bb1e-909635589410.png)

之后，程序会断在我们的断点部分，然后可以查看当前的堆栈状态，显示有一串字符串A在堆栈里：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605336910488-8a57d488-f6de-40ba-9e72-30d6d50597b5.png)

然后我说一些调试的快捷键，F2下断点，F7单步步入（一步一步执行，如果有函数会进入到函数里面），F8单步步出（一步一步执行，遇到函数，当做一个指令执行，不会进入函数内部），Ctrl + F9，执行到返回，就是运行到当前函数的返回指令。

我们需要进入这个strcpy的函数内部看一下，所以就按F7进入，我们可以看到左上角的汇编指令已经变了，然后右下角的堆栈区域压入了返回地址0x00401055，也就是上图中函数的下一条指令的地址：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605337433045-4fc48c41-e6d8-4bec-bd26-76a5efb4e332.png)

我们可以双击堆栈的第一列，这个地址的形式会变成相对的形式，可以更好的比对变化：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605337699508-4cf8eb5a-7922-41a4-ad3d-df83e993d1da.png)

这个时候，我们按一下Ctrl + F9，执行到当前函数的返回，然后看一下堆栈的变化，然后发现堆栈在往下滑会有一个区域有12个41，A转换为16进制的ASCII码就是41H：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605337909721-0b3e6ca9-0374-45fa-aca7-3b309d013358.png?x-oss-process=image%2Fresize%2Cw_1500)

往下滑，然后可以看到有一个返回地址，这一段应该是预分配的64个字节的堆栈区域：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605338218672-00c3479f-84b1-485d-a061-e3459df976c5.png)

我们可以通过写入过多的字符，然后将这个返回地址改为自己的想要的地址，甚至是去执行shellcode，我们重新打开文件，然后输入64+4+4个字符，最后这个应该就会覆盖返回地址：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605338572096-7359edd2-4869-4d67-9e93-ec2f7c61708f.png)

通过前面的相对位置也可以看出，也就是+9C这个位置的内容被覆盖了。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605338589358-e4bd8acf-5b97-4b53-9b1b-996e7622083a.png)

我们F7单步继续执行后，回到主函数，F8一步一步走到最后的retn，可以看到有一个push ebp，就把那个+98的内容放在了EBP里面，也就是我们也可以修改EBP：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605338815788-8a9be20b-44b4-4acd-adfe-1d29afbb1262.png)

之后我们F7继续执行，会发现左侧什么都没有了，然后右侧的寄存器变了，EIP编成了41414141，也就是下一条要执行的指令：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605339060693-26fd99f6-83a1-4fe8-99e0-4a0c936ae889.png)

以上就是一个简单的理解的实践，这个最后不见得能有什么效果出来，因为缓冲区溢出，涉及到返回地址的覆盖，然后还有一些“坏”字符，输入的话会产生截断等等，还有需要利用某个寄存器之类的，甚至还有需要查找某些装载到系统中是固定地址的模块的某个指令的地址，还要考虑到系统的一些保护机制，所以实际运用要学的还有很多。原文长有个针对Sync Breeze的缓冲区漏洞的讲解，但是我找不到指定版本的软件，有兴趣可以去查看 Penetration with Kali Linux 第11章。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2398693/1605322943507-dd4b310f-fac6-4ae9-a5a7-40e870ef74ea.png)